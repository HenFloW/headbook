[Back to readme](../README.md)

_Henrik Flo Wilhelmsen (hwi038)_

## 2c)

#### Best practices for storing passwords:

This app does not satisfy any of the best practices for storing passwords
The app stores the passwords in plain text in the database, this is not good because if someone gets access to the database they will have access to all the passwords.

And the password does not have any requirements, it can be as short as you want but theoretically empty but you can not get an empty password because in the update profile it has a check for if a password is in the form `if form.password.data:` and if form.password.data is "" that will be false and the password is not added. The password can be only numbers, this is not good because it will be easy to brute force the passwords.

to prevent this you can add more validators to the password field in the profile_form and the signup_form i added,

```py
password = PasswordField('Password', [
    validators.optional(),
    validators.equal_to('password_again', message='Passwords must match'),
    validators.Length(min=8, max=-1, message='Password must be minimum 8 characters long'),
    validators.Regexp('^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*(_|[^\w])).+$', message='Password must contain at least one lowercase letter, one uppercase letter, one digit and one special character')])
```

with this validation the password must be minimum 8 characters long and it must contain at least one lowercase letter, one uppercase letter, one digit and one special character, i also chose to make it optional so you can change your profile without changing your password. There is a check inside app.py for empty password

#### Implementing best practices for storing passwords:

I chose to make my own password hashing function, i used the hashlib library to hash the password with sha256 and then i used the base64 library to encode the hashed password to a string, i also added a salt to the password before hashing it, the salt is a random string of 16 characters uuid4, this is to prevent rainbow table attacks.

```py
import hashlib
import uuid

def hash_with_salt(password, salt):
    m = hashlib.sha256()
    m.update((salt + password).encode('utf-8'))
    return m.hexdigest()

def hash_password(password):
    salt = uuid.uuid4().hex
    return hash_with_salt(password, salt) + ':' + salt

def check_password(hashed, password):
    try:
      _hashed, salt = hashed.split(':')
      return _hashed == hash_with_salt(password, salt)
    except:
      return False
```

And then i changed the user class to use the hash_password function when creating a new user

```py
def save(self):
  """Save this user object to the database"""
  info = json.dumps(
      {k: self[k] for k in self if k not in ["username", "password", "id"]}
  )

  if "id" in self:
      sql_execute(
          f"UPDATE users SET username='{self.username}', password='{self.password}', info='{info}' WHERE id={self.id};"
      )
  else:
      sql_execute(
          f"INSERT INTO users (username, password, info) VALUES ('{self.username}', '{hash_password(self.password)}', '{info}');"
      )
      self.id = db.last_insert_rowid()
```
